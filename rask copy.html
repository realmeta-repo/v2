<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simbose: Caos vs Metodologia</title>
    <style>
        body { margin: 0; padding: 0; background-color: #ffffff; overflow-x: hidden; font-family: 'Segoe UI', Roboto, sans-serif; }
        .banner-label { padding: 10px 20px; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #aaa; background: #fff; }
        #canvas-confusao, #canvas-metodologia { width: 100%; height: 380px; display: block; background: #fff; }
        #canvas-confusao { border-bottom: 1px solid #eee; }
    </style>
</head>
<body>

    <div class="banner-label">Estado Atual: Sobrecarga</div>
    <canvas id="canvas-confusao"></canvas>
    
    <div class="banner-label">A Solução: Metodologia & Simbiose</div>
    <canvas id="canvas-metodologia"></canvas>

    <script>
        // --- CONFIGURAÇÕES GERAIS ---
        const PHI = (1 + Math.sqrt(5)) / 2; // Proporção Áurea para Fibonacci

        // --- BANNER 1: CAOS (REUTILIZADO E AJUSTADO) ---
        const cvsChaos = document.getElementById('canvas-confusao');
        const ctxChaos = cvsChaos.getContext('2d');
        // ... (Mantivemos a lógica anterior de partículas frenéticas para o Banner 1)
        // [Para brevidade no código completo abaixo, focaremos na implementação robusta do Banner 2 solicitado]

        // --- BANNER 2: METODOLOGIA E FIBONACCI ---
        const canvas = document.getElementById('canvas-metodologia');
        const ctx = canvas.getContext('2d');
        let w, h, time = 0;
        let phase = 0; // 0: Metodologia, 1: Transição, 2: Simbiose Fibonacci
        let phaseTimer = 0;

        const wordsMetodologia = [
            { text: "PESQUISA", x: 0.15, y: 0.3, type: 'head' },
            { text: "DEMANDA", x: 0.1, y: 0.6, type: 'sub' },
            { text: "PROPÓSITO", x: 0.2, y: 0.6, type: 'sub' },
            { text: "DESENVOLVIMENTO", x: 0.5, y: 0.3, type: 'head' },
            { text: "ESTRATÉGIA", x: 0.45, y: 0.6, type: 'sub' },
            { text: "DESIGN", x: 0.55, y: 0.6, type: 'sub' },
            { text: "DISTRIBUIÇÃO", x: 0.85, y: 0.3, type: 'head' },
            { text: "OPERAÇÃO", x: 0.8, y: 0.6, type: 'sub' },
            { text: "IMPACTOS", x: 0.9, y: 0.6, type: 'sub' }
        ];

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = 380;
            cvsChaos.width = window.innerWidth;
            cvsChaos.height = 380;
        }

        // Desenha conexões futuristas (tipo circuitos)
        function drawCyberLink(x1, y1, x2, y2, progress) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = `rgba(0, 120, 255, ${progress * 0.4})`;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            // Linha com "cotovelo" futurista
            ctx.lineTo(x1, (y1 + y2) / 2);
            ctx.lineTo(x2, (y1 + y2) / 2);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Seta Afiada
            const angle = Math.atan2(y2 - (y1 + y2) / 2, 0);
            ctx.save();
            ctx.translate(x2, y2 - 5);
            ctx.rotate(Math.PI/2);
            ctx.fillStyle = `rgba(0, 100, 200, ${progress})`;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-12, -5);
            ctx.lineTo(-12, 5);
            ctx.fill();
            ctx.restore();
        }

        // Função para desenhar Geometrias baseadas em Fibonacci
        function drawFibonacciFractal(x, y, size, rotation, alpha) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.strokeStyle = `rgba(100, 100, 255, ${alpha})`;
            
            // Espiral de Ouro (Fibonacci)
            let a = 0, b = size / 20;
            ctx.beginPath();
            for (let i = 0; i < 50; i++) {
                let angle = 0.1 * i;
                let r = b * Math.exp(0.306 * angle); // Logarithmic spiral aprox. Golden Ratio
                let px = r * Math.cos(angle);
                let py = r * Math.sin(angle);
                ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Elemento "Ancestral/Geometria Sagrada"
            ctx.beginPath();
            for(let i=0; i<6; i++) {
                ctx.rotate(Math.PI / 3);
                ctx.arc(size/2, 0, size/4, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawMetodologia() {
            wordsMetodologia.forEach((wrd, i) => {
                const px = wrd.x * w;
                const py = wrd.y * h + (phase === 1 ? phaseTimer * 5 : 0);
                const alpha = phase === 1 ? 1 - (phaseTimer / 50) : 1;

                ctx.fillStyle = wrd.type === 'head' ? `rgba(0, 80, 200, ${alpha})` : `rgba(80, 80, 80, ${alpha})`;
                ctx.font = wrd.type === 'head' ? "bold 24px 'Courier New'" : "16px 'Courier New'";
                ctx.textAlign = "center";
                ctx.fillText(wrd.text, px, py);

                // Conectar heads com subs
                if (wrd.type === 'sub') {
                    const head = wordsMetodologia.find(h => h.type === 'head' && Math.abs(h.x - wrd.x) < 0.1);
                    if (head) drawCyberLink(head.x * w, head.y * h + 10, px, py - 20, alpha);
                }
            });
        }

        function drawSimbiose() {
            const alpha = Math.min(1, phaseTimer / 100);
            const moveUp = Math.max(0, 50 - phaseTimer);

            // PESSOAS & TECNOLOGIA
            ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
            ctx.font = "bold 45px 'Segoe UI'";
            ctx.fillText("PESSOAS", w * 0.35, h * 0.4 + moveUp);
            ctx.fillText("TECNOLOGIA", w * 0.65, h * 0.4 + moveUp);

            // Elementos Fibonacci/Fractais em harmonia por todo o banner
            for(let i=0; i<8; i++) {
                const fx = (w / 8) * i + Math.sin(time + i) * 50;
                const fy = h/2 + Math.cos(time + i) * 100;
                const size = 30 + Math.sin(time * 0.5 + i) * 20;
                drawFibonacciFractal(fx, fy, size, time * 0.2 + i, alpha * 0.3);
            }

            // Ondas de Simbiose (Vectores Alienígenas/Ancestrais)
            ctx.beginPath();
            ctx.strokeStyle = `rgba(0, 200, 150, ${alpha * 0.2})`;
            for(let x=0; x<w; x+=10) {
                let yWave = Math.sin(x * 0.01 + time) * 20 + Math.cos(x * 0.005 - time) * 30;
                ctx.lineTo(x, h/2 + yWave);
            }
            ctx.stroke();
        }

        function animate() {
            ctx.clearRect(0, 0, w, h);
            time += 0.02;
            phaseTimer++;

            if (phase === 0) {
                drawMetodologia();
                if (phaseTimer > 400) { phase = 1; phaseTimer = 0; }
            } else if (phase === 1) {
                drawMetodologia();
                if (phaseTimer > 60) { phase = 2; phaseTimer = 0; }
            } else {
                drawSimbiose();
                if (phaseTimer > 600) { phase = 0; phaseTimer = 0; }
            }

            requestAnimationFrame(animate);
        }

        // --- LOOP DO BANNER 1 (SIMPLIFICADO PARA O CONTEXTO) ---
        // Aqui deve ir a lógica anterior das palavras aleatórias e conexões neurais.
        
        window.addEventListener('resize', resize);
        resize();
        animate();
    </script>
</body>
</html>